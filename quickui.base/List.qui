<!--
Creates a set of controls, one for each item in a list.
-->

<Control name="List">

<script>
List.prototype.extend({
    
    // The control class that should be used to render items in the list.
    itemClass: Control.property["class"](function() { this._refresh(); }, Control),
    
    // True if the control should mark itself dirty when it gets a change event.
    dirtyOnChange: Control.property.bool(null, false),
    
    // True if the control contents have been changed since the controls were first created.
    isDirty: Control.property.bool(null, true),
    
    // A copy of the items the last time they were created or refreshed.
    _itemsCache: Control.property(),
    
    initialize: function() {
        var self = this;
        this.change(function(event) {
            if (self.dirtyOnChange()) {
                // Assume the list is dirty.
                self.isDirty(true);
            }
        });
    },
    
    /*
     * The collection of controls in the list generated by setting the items() property.
     * This is always returned as an instance of itemClass.
     */
    controls: function() {
        var itemClass = this.itemClass();
        return itemClass(this).children();
    },
    
    // The items in the list.
    items: function(items) {
        if (items === undefined)
        {
            if (this.isDirty())
            {
                this
                    ._itemsCache(this._getItemsFromControls())
                    .isDirty(false);
            }
            return this._itemsCache();
        }
        else
        {
            return this
                ._itemsCache(items)
                ._createControlsForItems(items)
                .isDirty(false);
        }
    },
    
    //
    // Used to map an incoming list item to property setters on the control
    // class indicated by itemClass. This can either be a simple string,
    // in which case it will be taken as the name of a control class property,
    // Alternately, this can be a function of the form:
    //
    //      function foo(index, item) { ... }
    //
    // where index is control's position in the list, and item is the list item.
    // If item is undefined, the map function is being invoked as a getter,
    // and should extract the item from the control (available via "this").
    // If item is defined, the map function is being invoked as a setter, and
    // should pass the item to the control (e.g., by setting properties on it).
    //
    mapFunction: Control.property(
        function() { this._refresh(); },
        "content"
    ),
    
    _createControlsForItems: function(items) {
        var itemClass = this.itemClass();
        var mapFunction = this._getMapFunction();
        var controls = $.map(items || [], function(item, index) {
            var $control = itemClass.create();
            mapFunction.call($control, index, item);
            return $control;
        });
        this.content(controls);
        return this;
    },
    
    _getItemsFromControls: function() {
        var mapFunction = this._getMapFunction();
        return this.controls().map(function(index, element) {
            var $control = $(element).control();
            return mapFunction.call($control, index);
        }).get();
    },
    
    /*
     * If the list's mapFunction property is a simple string, create a
     * function that invokes the item control's property getter/setter with
     * that string name. Otherwise, return the mapFunction value as is.  
     */
    _getMapFunction: function() {
        var mapFunction = this.mapFunction();
        return typeof mapFunction === "string"
            ? function(index, item) { return this[mapFunction](item); }
            : mapFunction;
    },

    // Get all the items, then recreate them again (possibly as different controls).        
    _refresh: function() {
        this.items(this.items());
    }

});
</script>

</Control>
